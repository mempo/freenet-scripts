#!/bin/bash
# TODO: bin is a silly place to put such a configuration file. It'd make more sense to have a config value in the rc.
# Put the real keys in ~/bin/insert-update-keys
# Shared utility functions.
source freenet-scripts-common || exit
readConfig

SEEDNODESFILE="$releaseDir/seednodes.fref"

getBuildInfo
if [[ -z "$gitVersion" ]]; then echo Could not get git version; exit 1; fi

echo Build number $buildNumber git tag $gitVersion

# TODO: Any reason to specify more than -d? Why make two temporary directories? Is this under the assumption that /tmp is tmpfsand swap is encrypted, to avoid writing it to disk? Seems unnecessary.
KEYS="$(mktemp -d -p /tmp temp.XXXXXXXX)"
if [ ! -f "$countryDataFile" ]; then
    echo WARNING: Inserting without country data;
fi

# Decrypt keys.
gpg -o $KEYS/keys ~/bin/insert-update-keys.gpg || exit
# TODO: Update keys is some kind of script? Has config values?
source $KEYS/keys || exit

TEMPLOC="$(mktemp -d)"
echo Temporary file location: $TEMPLOC

git clone "$fredDir" "$TEMPLOC" || exit
cd "$TEMPLOC"
# TODO: What modified files would there be in a repo that was just cloned? Why mess with the repo or what look like vestiges of building it? The source archive already exists as part of release-fred.
git reset --hard
git checkout "$gitVersion" || exit
cp "$freenetExtPath" lib/freenet-ext.jar || exit
ant clean
# TODO: Huh? Why copy here?
cp "$releaseDir/freenet-$gitVersion.jar" lib/freenet-cvs-snapshot.jar

FILENAME="$releaseDir/freenet-$gitVersion.jar"
SOURCENAME="$releaseDir/freenet-$gitVersion-source.tar.bz2"
if [[ ! -e $FILENAME ]]; then echo Jar not found; exit; fi
if [[ ! -e $SOURCENAME ]]; then echo Source not found; exit; fi
echo Inserting update for build number $buildNumber

# Enable job control. TODO: Why?
set -m

# SECURITY: Insert via secondary testing node, NOT VIA MAIN NODE
# This avoids the insert keys ever being known to the main node.
# TODO: Why on earth is this a loop?
for PORT in 9482; do

# TODO: Why put this in a file?
TEMPFILE1="$(mktemp /tmp/insert.temp.XXXXXXXXXX)"
echo Temp file $TEMPFILE1
echo ClientHello > $TEMPFILE1
echo "Name=Toad-update-$buildNumber" >> $TEMPFILE1
echo ExpectedVersion=2 >> $TEMPFILE1
echo End >> $TEMPFILE1
echo >> $TEMPFILE1

INSTALLERFILE="$releaseDir/new_installer_offline_$buildNumber.jar"
WININSTALLERFILE="$releaseDir/FreenetInstaller-$buildNumber.exe"

if [[ ! -f "$INSTALLERFILE" ]]
then
  echo Installer file does not exist: $INSTALLERFILE
  exit
fi

if [[ ! -f $WININSTALLERFILE ]]
then
    echo Windows installer file does not exist: $WININSTALLERFILE
    exit
fi

# TODO: Why is this in a loop? Could it be in a single message that inserts a collection of files? How to document this as the list of things that are inserted as part of an update?
for WHAT in binary source installer wininstaller seednodes changelog fullchangelog iptocountryv4; do

# Insert the binary LAST so that the node doesn't restart before completing the insert. TODO: Meaning that a node could restart as part of auto-update with the update it just inserted?
PCLASS=0
URI=NEWKEY
IDENT=update-new-$buildNumber

# TODO: This is a mapping between names and details on how to insert it. Why put this in a loop instead of having these things as part of sending a large message to the node. (So direct-ish echos to the node.)
if [[ $WHAT == "source" ]]; then
  INSERTFILE=$SOURCENAME
  PCLASS=$((PCLASS+3))
  URI=${URI}/update-source-$buildNumber
  IDENT=${IDENT}-source
fi
if [[ $WHAT == "installer" ]]; then
  INSERTFILE=$INSTALLERFILE
  URI=${URI}/installer-$buildNumber
  IDENT=${IDENT}-installer
  PCLASS=$((PCLASS+2))
fi
if [[ $WHAT == "wininstaller" ]]; then
  INSERTFILE=$WININSTALLERFILE
  URI=${URI}/wininstaller-${buildNumber}
  IDENT=${IDENT}-wininstaller
  PCLASS=$((PCLASS+2))
fi
if [[ $WHAT == "binary" ]]; then
  INSERTFILE=$FILENAME
  URI=${URI}/jar-$buildNumber
  PCLASS=$((PCLASS))
fi
if [[ $WHAT == "seednodes" ]]; then
  INSERTFILE=$SEEDNODESFILE
  URI=${URI}/seednodes-$buildNumber
  IDENT=${IDENT}-seednodes
fi
if [[ $WHAT == "changelog" ]]; then
  INSERTFILE=$releaseDir/changelog.short.$gitVersion.txt
  URI=${URI}/changelog-$buildNumber
  IDENT=${IDENT}-changelog
fi
if [[ $WHAT == "fullchangelog" ]]; then
  INSERTFILE=$releaseDir/changelog.full.$gitVersion.txt
  URI=${URI}/fullchangelog-$buildNumber
  IDENT=${IDENT}-fullchangelog
fi
if [[ $WHAT == "iptocountryv4" ]]; then
  INSERTFILE=$countryDataFile
  URI=${URI}/iptocountryv4-$buildNumber
  IDENT=${IDENT}-iptocountryv4
  PCLASS=$((PCLASS+2))
fi

TEMPFILE="$(mktemp /tmp/insert.temp.XXXXXXXXXX)"
echo ClientPut >> $TEMPFILE
# TODO: Why not compress?
echo "DontCompress=true" >> $TEMPFILE
# TODO: Why this mode? Seems unneccesary.
echo "CompatibilityMode=COMPAT_1250_EXACT" >> $TEMPFILE
echo "URI=$URI" >> $TEMPFILE
echo "Identifier=$IDENT" >> $TEMPFILE
# TODO: What flags does this set?
echo Verbosity=1023 >> $TEMPFILE
# TODO: Remind me what that does? Never stop trying?
echo MaxRetries=-1 >> $TEMPFILE
echo UploadFrom=direct >> $TEMPFILE
# TODO: wc -c instead of relying on the ls -l format?
echo DataLength=`ls -l $INSERTFILE | cut -d " " -f 5` >> $TEMPFILE
# SECURITY: Persistence=reboot so the keys are never written to disk
echo Persistence=reboot >> $TEMPFILE
echo PriorityClass=$PCLASS >> $TEMPFILE
echo Global=true >> $TEMPFILE
# TODO: So the final line of a message before data need not be "Data"? It doesn't matter? FCP docs on the wiki currently imply otherwise.
echo End >> $TEMPFILE

SCRIPT="$KEYS/script"
echo -n "s/NEWKEY/" > $SCRIPT
# TODO: What the hell?
cat $KEYS/keys | sed -n "s/NEWKEY=\"\(.*\)\"/\1/p" >> $SCRIPT
cat $SCRIPT | tr --delete "\n" > ${SCRIPT}.1 && mv ${SCRIPT}.1 $SCRIPT
echo "/" >> $SCRIPT
# TODO: That built a sed expression which does... what? Why involve a file? Why do it each iteration when it as far as I can tell will be the same each time? It has something to do with modifying the FCP message.
cat $TEMPFILE | sed -f $SCRIPT > $TEMPFILE.1
mv $TEMPFILE.1 $TEMPFILE

# Add message as constructed, followed by the data of the file itself.
cat $TEMPFILE >> $TEMPFILE1
cat $INSERTFILE >> $TEMPFILE1
rm $TEMPFILE

done

SCRIPT="$KEYS/script"

# TODO: What about having all the above be echos (perhaps in a similar loop) piped into nc?
cat $TEMPFILE1 | nc 127.0.0.1 $PORT | sed "/^URI=/d"

done

rm -Rf $KEYS
rm -Rf $TEMPFILE1
